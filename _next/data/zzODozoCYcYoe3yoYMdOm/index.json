{"pageProps":{"items":[{"title":"gcloud-aio-bigqueryでasync/awaitを使ってBigQueryのクエリを叩く","link":"https://nazo.hatenablog.com/entry/gcloud-aio-bigquery","pubDate":"2024-01-09T03:00:00.000Z","author":"nazone","content":"<p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Python\">Python</a>からBigQueryを叩くには公式の <a href=\"https://pypi.org/project/google-cloud-bigquery/\">google-cloud-bigquery</a> があるのですが、asyncioに対応していません。</p>\n\n<p>一部のライブラリではv2側でasyncioに対応しているのですが、BigQueryはv2でも対応していないように見えます。ちなみにv1はほとんどの実装で<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>を叩いて、v2はほとんどの実装でRPC <a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>を叩いています（どちらも全部確認したわけではありません）。一部のライブラリでv2のほうを叩くとサーバーエラーが多発したこともあり、今のところなるべくv1でasyncioを使用したいです。</p>\n\n<p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/GCP\">GCP</a>の<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Python\">Python</a>ライブラリをasyncioで動くように書き換えたものが <a href=\"https://github.com/talkiq/gcloud-aio\">gcloud-aio</a> で用意されており、その中に <a href=\"https://pypi.org/project/gcloud-aio-bigquery/\">gcloud-aio-bigquery</a> があります。あまり使われているのを見かけませんが、<a href=\"https://github.com/apache/airflow/blob/08f6e2e5d21382494597e6cac66725bc85729656/airflow/providers/google/provider.yaml#L89C1-L91\">AirflowのGCP周りの一部で使われている</a>ようです。</p>\n\n<p>ただし<a href=\"https://cloud.google.com/bigquery/docs/reference/rest\">REST API</a>そのままの実装になっているため、<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>の知識が必要です。手軽に使えるとは言い難いです。</p>\n\n<h1 id=\"REST-APIでの流れ\"><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>での流れ</h1>\n\n<p>まずクエリを実行するには <a href=\"https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query\">jobs.query</a> を呼びます。</p>\n\n<p>代表的なパラメーターは以下の通りです。</p>\n\n<ul>\n<li>query : 必須。<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SQL\">SQL</a>クエリを指定する。</li>\n<li>maxResults : １レスポンスに含まれる行数。指定しなくてもバイト数でページングされるが、指定しておいたほうが安全。</li>\n<li>timeoutMs : <a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%A2%A5%A6%A5%C8\">タイムアウト</a>の秒数</li>\n<li>useLegacySql : BigQueryのレガシー<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SQL\">SQL</a>を使用するかどうか。デフォルトtrueなのでfalseを指定しておいたほうがいい。</li>\n</ul>\n\n\n<p>実行するとジョブが作成されます。</p>\n\n<p>レスポンスを確認してデータが完結しているか確認します。 <code>jobComplete</code> が true の場合、ジョブが完了して結果の行を取得できる状態です。この場合、 <code>rows</code> に結果の行が含まれています。また、 <code>schema</code> に<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE\">スキーマ</a>が含まれています。 <code>rows</code> だけ見てもどの列の何のデータがの判別が難しいので、 <code>schema</code> と合わせて確認します。</p>\n\n<p><code>jobComplete</code> が true で、 <code>pageToken</code> が含まれている場合、まだ読み込むべきデータが残っているので続きを読み込みます。 <code>pageToken</code> が無ければ終了です。</p>\n\n<p>データが完結していない場合は、レスポンスの <code>jobReference</code> の <code>jobId</code> を拾って、（ <code>pageToken</code> があればそれも一緒に）  <a href=\"https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults\">jobs.getQueryResults</a> を実行します。結果は jobs.query と同じです。</p>\n\n<p>全体の流れをまとめると以下のようになります。</p>\n\n<ul>\n<li>jobs.query でジョブを作成</li>\n<li>jobComplete が true なら\n\n<ul>\n<li>rows がない（totalRows=0）→終了</li>\n<li>rows がある→そのデータを使う</li>\n<li>pageToken がない→終了</li>\n</ul>\n</li>\n<li>jobComplete が false 、または pageToken がある→ jobs.getQueryResults を実行し、上の判定ロジックに戻る</li>\n</ul>\n\n\n<h1 id=\"実際に使ってみる\">実際に使ってみる</h1>\n\n<p>実際に動くものが以下になります。</p>\n\n<pre class=\"code lang-python\" data-lang=\"python\" data-unlink><span class=\"synPreProc\">import</span> asyncio\n<span class=\"synPreProc\">from</span> collections.abc <span class=\"synPreProc\">import</span> AsyncGenerator\n\n<span class=\"synPreProc\">import</span> aiohttp\n<span class=\"synPreProc\">from</span> gcloud.aio.bigquery <span class=\"synPreProc\">import</span> Job\n<span class=\"synPreProc\">from</span> google.cloud <span class=\"synPreProc\">import</span> bigquery\n<span class=\"synPreProc\">from</span> google.cloud.bigquery._helpers <span class=\"synPreProc\">import</span> _rows_from_json\n<span class=\"synPreProc\">from</span> google.cloud.bigquery.table <span class=\"synPreProc\">import</span> _parse_schema_resource  <span class=\"synComment\"># type:ignore</span>\n\n\n<span class=\"synStatement\">async</span> <span class=\"synStatement\">def</span> <span class=\"synIdentifier\">query</span>(\n    sql: <span class=\"synIdentifier\">str</span>, max_results: <span class=\"synIdentifier\">int</span> = <span class=\"synConstant\">100</span>\n) -&gt; AsyncGenerator[<span class=\"synIdentifier\">list</span>[bigquery.Row], <span class=\"synIdentifier\">None</span>]:\n    loop = asyncio.get_running_loop()\n    <span class=\"synStatement\">async</span> <span class=\"synStatement\">with</span> aiohttp.ClientSession(loop=loop) <span class=\"synStatement\">as</span> session:\n        job = Job(session=session)\n        query_request = {\n            <span class=\"synConstant\">&quot;query&quot;</span>: sql,\n            <span class=\"synConstant\">&quot;maxResults&quot;</span>: max_results,\n            <span class=\"synConstant\">&quot;useLegacySql&quot;</span>: <span class=\"synConstant\">&quot;false&quot;</span>,\n        }\n        response = <span class=\"synStatement\">await</span> job.query(query_request=query_request)\n        <span class=\"synStatement\">while</span> <span class=\"synIdentifier\">True</span>:\n            errors = response.get(<span class=\"synConstant\">&quot;errors&quot;</span>)\n            page_token = response.get(<span class=\"synConstant\">&quot;pageToken&quot;</span>)\n            <span class=\"synStatement\">if</span> errors <span class=\"synStatement\">is</span> <span class=\"synStatement\">not</span> <span class=\"synIdentifier\">None</span>:\n                <span class=\"synStatement\">raise</span> <span class=\"synType\">RuntimeError</span>(errors)\n            <span class=\"synStatement\">if</span> response.get(<span class=\"synConstant\">&quot;jobComplete&quot;</span>):\n                <span class=\"synStatement\">if</span> <span class=\"synIdentifier\">int</span>(response.get(<span class=\"synConstant\">&quot;totalRows&quot;</span>, <span class=\"synConstant\">0</span>)) == <span class=\"synConstant\">0</span>:\n                    <span class=\"synStatement\">return</span>\n                schema = _parse_schema_resource(response.get(<span class=\"synConstant\">&quot;schema&quot;</span>, {}))\n                <span class=\"synStatement\">yield</span> _rows_from_json(response.get(<span class=\"synConstant\">&quot;rows&quot;</span>, ()), schema)\n                <span class=\"synStatement\">if</span> page_token <span class=\"synStatement\">is</span> <span class=\"synIdentifier\">None</span>:\n                    <span class=\"synStatement\">return</span>\n            <span class=\"synStatement\">else</span>:\n                <span class=\"synStatement\">await</span> asyncio.sleep(<span class=\"synConstant\">1.0</span>)  <span class=\"synComment\"># 終わってなさそうなので少し待つ</span>\n            <span class=\"synComment\"># ジョブの結果を確認</span>\n            job = Job(\n                job_id=response[<span class=\"synConstant\">&quot;jobReference&quot;</span>][<span class=\"synConstant\">&quot;jobId&quot;</span>],\n                project=response[<span class=\"synConstant\">&quot;jobReference&quot;</span>][<span class=\"synConstant\">&quot;projectId&quot;</span>],\n                session=session,\n            )\n            params = {\n                <span class=\"synConstant\">&quot;location&quot;</span>: response[<span class=\"synConstant\">&quot;jobReference&quot;</span>][<span class=\"synConstant\">&quot;location&quot;</span>],\n                <span class=\"synConstant\">&quot;maxResults&quot;</span>: max_results,\n                <span class=\"synConstant\">&quot;pageToken&quot;</span>: page_token,\n            }\n            response = <span class=\"synStatement\">await</span> job.get_query_results(params=params)\n\n\n<span class=\"synStatement\">async</span> <span class=\"synStatement\">def</span> <span class=\"synIdentifier\">main</span>() -&gt; <span class=\"synIdentifier\">None</span>:\n    <span class=\"synStatement\">async</span> <span class=\"synStatement\">for</span> rows <span class=\"synStatement\">in</span> query(<span class=\"synConstant\">&quot;SELECT * FROM `project_id.dataset_id.table`&quot;</span>):\n        <span class=\"synStatement\">for</span> row <span class=\"synStatement\">in</span> rows:\n            <span class=\"synComment\"># row[&quot;key&quot;] で値を取得可能</span>\n            <span class=\"synStatement\">for</span> key, value <span class=\"synStatement\">in</span> row.items():\n                <span class=\"synIdentifier\">print</span>(f<span class=\"synConstant\">&quot;{key}={value}&quot;</span>)\n\n\n<span class=\"synStatement\">if</span> __name__ == <span class=\"synConstant\">&quot;__main__&quot;</span>:\n    asyncio.run(main())\n</pre>\n\n\n<p>雑に書いているので必要に応じて書き換えてください。<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%BF%A5%A4%A5%E0%A5%A2%A5%A6%A5%C8\">タイムアウト</a>の設定や例外の処理などが別途必要になります。</p>\n\n<p>結果行の整形に公式の <code>google-cloud-bigquery</code> も使っています。また、 <code>aiohttp</code> パッケージも必要です。</p>\n\n<p>プロジェクトIDを指定したい場合は Job のコンスト<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タで指定してもいいですし、<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a> <code>GOOGLE_CLOUD_PROJECT</code> などで指定しても反映されます。</p>\n\n<h1 id=\"まとめ\">まとめ</h1>\n\n<p>公式で対応してほしいです。</p>\n","contentSnippet":"PythonからBigQueryを叩くには公式の google-cloud-bigquery があるのですが、asyncioに対応していません。\n一部のライブラリではv2側でasyncioに対応しているのですが、BigQueryはv2でも対応していないように見えます。ちなみにv1はほとんどの実装でREST APIを叩いて、v2はほとんどの実装でRPC APIを叩いています（どちらも全部確認したわけではありません）。一部のライブラリでv2のほうを叩くとサーバーエラーが多発したこともあり、今のところなるべくv1でasyncioを使用したいです。\nGCPのPythonライブラリをasyncioで動くように書き換えたものが gcloud-aio で用意されており、その中に gcloud-aio-bigquery があります。あまり使われているのを見かけませんが、AirflowのGCP周りの一部で使われているようです。\nただしREST APIそのままの実装になっているため、REST APIの知識が必要です。手軽に使えるとは言い難いです。\nREST APIでの流れ\nまずクエリを実行するには jobs.query を呼びます。\n代表的なパラメーターは以下の通りです。\nquery : 必須。SQLクエリを指定する。\nmaxResults : １レスポンスに含まれる行数。指定しなくてもバイト数でページングされるが、指定しておいたほうが安全。\ntimeoutMs : タイムアウトの秒数\nuseLegacySql : BigQueryのレガシーSQLを使用するかどうか。デフォルトtrueなのでfalseを指定しておいたほうがいい。\n実行するとジョブが作成されます。\nレスポンスを確認してデータが完結しているか確認します。 jobComplete が true の場合、ジョブが完了して結果の行を取得できる状態です。この場合、 rows に結果の行が含まれています。また、 schema にスキーマが含まれています。 rows だけ見てもどの列の何のデータがの判別が難しいので、 schema と合わせて確認します。\njobComplete が true で、 pageToken が含まれている場合、まだ読み込むべきデータが残っているので続きを読み込みます。 pageToken が無ければ終了です。\nデータが完結していない場合は、レスポンスの jobReference の jobId を拾って、（ pageToken があればそれも一緒に）  jobs.getQueryResults を実行します。結果は jobs.query と同じです。\n全体の流れをまとめると以下のようになります。\njobs.query でジョブを作成\njobComplete が true なら\n\n\nrows がない（totalRows=0）→終了\nrows がある→そのデータを使う\npageToken がない→終了\njobComplete が false 、または pageToken がある→ jobs.getQueryResults を実行し、上の判定ロジックに戻る\n実際に使ってみる\n実際に動くものが以下になります。\nimport asyncio\nfrom collections.abc import AsyncGenerator\n\nimport aiohttp\nfrom gcloud.aio.bigquery import Job\nfrom google.cloud import bigquery\nfrom google.cloud.bigquery._helpers import _rows_from_json\nfrom google.cloud.bigquery.table import _parse_schema_resource  # type:ignore\n\n\nasync def query(\n    sql: str, max_results: int = 100\n) -> AsyncGenerator[list[bigquery.Row], None]:\n    loop = asyncio.get_running_loop()\n    async with aiohttp.ClientSession(loop=loop) as session:\n        job = Job(session=session)\n        query_request = {\n            \"query\": sql,\n            \"maxResults\": max_results,\n            \"useLegacySql\": \"false\",\n        }\n        response = await job.query(query_request=query_request)\n        while True:\n            errors = response.get(\"errors\")\n            page_token = response.get(\"pageToken\")\n            if errors is not None:\n                raise RuntimeError(errors)\n            if response.get(\"jobComplete\"):\n                if int(response.get(\"totalRows\", 0)) == 0:\n                    return\n                schema = _parse_schema_resource(response.get(\"schema\", {}))\n                yield _rows_from_json(response.get(\"rows\", ()), schema)\n                if page_token is None:\n                    return\n            else:\n                await asyncio.sleep(1.0)  # 終わってなさそうなので少し待つ\n            # ジョブの結果を確認\n            job = Job(\n                job_id=response[\"jobReference\"][\"jobId\"],\n                project=response[\"jobReference\"][\"projectId\"],\n                session=session,\n            )\n            params = {\n                \"location\": response[\"jobReference\"][\"location\"],\n                \"maxResults\": max_results,\n                \"pageToken\": page_token,\n            }\n            response = await job.get_query_results(params=params)\n\n\nasync def main() -> None:\n    async for rows in query(\"SELECT * FROM `project_id.dataset_id.table`\"):\n        for row in rows:\n            # row[\"key\"] で値を取得可能\n            for key, value in row.items():\n                print(f\"{key}={value}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n\n\n雑に書いているので必要に応じて書き換えてください。タイムアウトの設定や例外の処理などが別途必要になります。\n結果行の整形に公式の google-cloud-bigquery も使っています。また、 aiohttp パッケージも必要です。\nプロジェクトIDを指定したい場合は Job のコンストラクタで指定してもいいですし、環境変数 GOOGLE_CLOUD_PROJECT などで指定しても反映されます。\nまとめ\n公式で対応してほしいです。","summary":"PythonからBigQueryを叩くには公式の google-cloud-bigquery があるのですが、asyncioに対応していません。 一部のライブラリではv2側でasyncioに対応しているのですが、BigQueryはv2でも対応していないように見えます。ちなみにv1はほとんどの実装でREST APIを叩いて、v2はほとんどの実装でRPC APIを叩いています（どちらも全部確認したわけではありません）。一部のライブラリでv2のほうを叩くとサーバーエラーが多発したこともあり、今のところなるべくv1でasyncioを使用したいです。 GCPのPythonライブラリをasyncioで動く…","id":"hatenablog://entry/6801883189072194905","isoDate":"2024-01-09T03:00:00.000Z"},{"title":"nazoさんの2023年とこれから（お仕事募集中です！！）","link":"https://nazo.hatenablog.com/entry/2023-works","pubDate":"2023-12-29T03:00:00.000Z","author":"nazone","content":"<ul>\n<li>2022年 : <a href=\"https://nazo.hatenablog.com/entry/2022-works\">https://nazo.hatenablog.com/entry/2022-works</a></li>\n<li>2021年 : <a href=\"https://nazo.hatenablog.com/entry/2021-works\">https://nazo.hatenablog.com/entry/2021-works</a></li>\n<li>2020年 : <a href=\"https://nazo.hatenablog.com/entry/2020-works\">https://nazo.hatenablog.com/entry/2020-works</a></li>\n<li>2019年 : <a href=\"https://nazo.hatenablog.com/entry/goodbye-uuum\">https://nazo.hatenablog.com/entry/goodbye-uuum</a></li>\n</ul>\n\n\n<h1 id=\"何してたの\">何してたの？</h1>\n\n<p>一応、仕事しています。</p>\n\n<p>あまり細かいことは言えないのですが、<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Python\">Python</a>でGraphQLでBigQuery x <a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/BigTable\">BigTable</a>でPub/Subで…とかしつつ開発組織の<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%B5%A5%EB%A5%C6%A5%A3%A5%F3%A5%B0\">コンサルティング</a>的なこともしていました。キューでタスクを分割する仕組みが思ったより快適すぎるので今後もっと使っていきたいと思いました。</p>\n\n<p>最近の<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Python\">Python</a>は型検査にasync/awaitとか使えて快適ですね。開発環境は<a href=\"https://github.com/mitsuhiko/rye\">rye</a>で、black+mypy+ruff で各種検査を回しまくると<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/VSCode\">VSCode</a>で自動修正やら補完やらが効きまくって今までの<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Python\">Python</a>とは別世界です。強いて言えば各種ライブラリ（特に<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Google\">Google</a>系）が最新のあれこれに対応していなかったりするのが難点ですね。</p>\n\n<p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/GitHub\">GitHub</a> Copliotが優秀すぎてコードの書き方より指示コメントの書き方がうまくなってきました。テストケースなんかも半自動生成できて、ちまちま作ってたようなものがどんどん楽になりますね。Codeじゃない<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/VIsual%20Studio\">VIsual Studio</a>だと標準で入っているので、Unityを書くのとかでもものすごく楽になりました。知ってるか知らないか、知っていたら勝ちみたいな領域で勝負していた方々は今後辛いんじゃないでしょうか。</p>\n\n<h1 id=\"SNS断ち特にX\"><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>断ち（特にX）</h1>\n\n<p>もう存在を忘れられているかと思いますが、結構前から<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>をほぼ引退しました。X（旧<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Twitter\">Twitter</a>）も<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/Facebook\">Facebook</a>も過去の投稿をほぼ全て削除してありますし、特殊な事情がない限り告知以外の投稿をすることはもうありません。この記事の通知は流れているはずなので、<a href=\"https://x.com/nazo\">https://x.com/nazo</a> は告知用アカウントだと思ってください。</p>\n\n<p>理由としては、コロナ禍あたりからの空気の変化により、少なくともXを使い続けるのは自分にとってメリットよりデメリットのほうが上回ってきたからです。X社関係の騒動とはあまり関係ありません。</p>\n\n<p>このブログは<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>ではないので、基本的にこのブログは更新し続けるつもりです。</p>\n\n<p>一応Blueskyのアカウント（ <a href=\"https://bsky.app/profile/nazonazo.bsky.social\">https://bsky.app/profile/nazonazo.bsky.social</a> ）も取得してあり、万が一普段遣いとして復帰したくなった場合はこちらを使うかもしれませんが、まあそれも今のところはなさそうです。</p>\n\n<p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>断ちをして思ったことは、思ったより<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>を見てメールをくれたり連絡をしてくれたりする人というのはいたんだなということです。<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>を動かしている間はそれなりに反応があったのですが、断ってからはスパム的なもの以外は全く来なくなってしまいました。まあブログくらい書いていればもう少し違うのでしょうが…。</p>\n\n<p>交友関係もほぼ断ってしまったので、すっかりお仕事の話も途絶えてしまいました。難しい話です。</p>\n\n<h1 id=\"今後について\">今後について</h1>\n\n<p>今の生活はとても自分に合っているので、できれば今の生活を続けていきたいのですが、特にこの先の見通しもないし収入面の不安もあるので難しそうです。</p>\n\n<p>自分ももうすぐ42歳になり、日に日に体力も衰え、絶対にこれをやるんだ！みたいなモチベーションはもうないのですが、成功事例も増えてきましたし、自分にしかできないことも少なくないはずなので、淡々とできることをこなしていこうと思います。</p>\n\n<h1 id=\"お仕事募集中\">お仕事募集中</h1>\n\n<p>引き続きお仕事を募集しております。週２〜４くらいまで・フルリモート・単価多分そこそこ高め？です。解決できる課題などは\n<a href=\"https://nazo.dev/profile\">https://nazo.dev/profile</a> をご覧下さい。フルタイム正社員でないからこそできる内容をメインにしています。</p>\n\n<p>各種<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/SNS\">SNS</a>のDMでご連絡をお待ちしております。</p>\n","contentSnippet":"2022年 : https://nazo.hatenablog.com/entry/2022-works\n2021年 : https://nazo.hatenablog.com/entry/2021-works\n2020年 : https://nazo.hatenablog.com/entry/2020-works\n2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum\n何してたの？\n一応、仕事しています。\nあまり細かいことは言えないのですが、PythonでGraphQLでBigQuery x BigTableでPub/Subで…とかしつつ開発組織のコンサルティング的なこともしていました。キューでタスクを分割する仕組みが思ったより快適すぎるので今後もっと使っていきたいと思いました。\n最近のPythonは型検査にasync/awaitとか使えて快適ですね。開発環境はryeで、black+mypy+ruff で各種検査を回しまくるとVSCodeで自動修正やら補完やらが効きまくって今までのPythonとは別世界です。強いて言えば各種ライブラリ（特にGoogle系）が最新のあれこれに対応していなかったりするのが難点ですね。\nGitHub Copliotが優秀すぎてコードの書き方より指示コメントの書き方がうまくなってきました。テストケースなんかも半自動生成できて、ちまちま作ってたようなものがどんどん楽になりますね。CodeじゃないVIsual Studioだと標準で入っているので、Unityを書くのとかでもものすごく楽になりました。知ってるか知らないか、知っていたら勝ちみたいな領域で勝負していた方々は今後辛いんじゃないでしょうか。\nSNS断ち（特にX）\nもう存在を忘れられているかと思いますが、結構前からSNSをほぼ引退しました。X（旧Twitter）もFacebookも過去の投稿をほぼ全て削除してありますし、特殊な事情がない限り告知以外の投稿をすることはもうありません。この記事の通知は流れているはずなので、https://x.com/nazo は告知用アカウントだと思ってください。\n理由としては、コロナ禍あたりからの空気の変化により、少なくともXを使い続けるのは自分にとってメリットよりデメリットのほうが上回ってきたからです。X社関係の騒動とはあまり関係ありません。\nこのブログはSNSではないので、基本的にこのブログは更新し続けるつもりです。\n一応Blueskyのアカウント（ https://bsky.app/profile/nazonazo.bsky.social ）も取得してあり、万が一普段遣いとして復帰したくなった場合はこちらを使うかもしれませんが、まあそれも今のところはなさそうです。\nSNS断ちをして思ったことは、思ったよりSNSを見てメールをくれたり連絡をしてくれたりする人というのはいたんだなということです。SNSを動かしている間はそれなりに反応があったのですが、断ってからはスパム的なもの以外は全く来なくなってしまいました。まあブログくらい書いていればもう少し違うのでしょうが…。\n交友関係もほぼ断ってしまったので、すっかりお仕事の話も途絶えてしまいました。難しい話です。\n今後について\n今の生活はとても自分に合っているので、できれば今の生活を続けていきたいのですが、特にこの先の見通しもないし収入面の不安もあるので難しそうです。\n自分ももうすぐ42歳になり、日に日に体力も衰え、絶対にこれをやるんだ！みたいなモチベーションはもうないのですが、成功事例も増えてきましたし、自分にしかできないことも少なくないはずなので、淡々とできることをこなしていこうと思います。\nお仕事募集中\n引き続きお仕事を募集しております。週２〜４くらいまで・フルリモート・単価多分そこそこ高め？です。解決できる課題などは\nhttps://nazo.dev/profile をご覧下さい。フルタイム正社員でないからこそできる内容をメインにしています。\n各種SNSのDMでご連絡をお待ちしております。","summary":"2022年 : https://nazo.hatenablog.com/entry/2022-works 2021年 : https://nazo.hatenablog.com/entry/2021-works 2020年 : https://nazo.hatenablog.com/entry/2020-works 2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum 何してたの？ 一応、仕事しています。 あまり細かいことは言えないのですが、PythonでGraphQLでBigQuery x BigTableでPub/Subで…とかしつつ…","id":"hatenablog://entry/6801883189057845489","isoDate":"2023-12-29T03:00:00.000Z"},{"title":"webtransport-goでチャットを作ってみた","link":"https://nazo.hatenablog.com/entry/webtransport-go-chat","pubDate":"2023-01-27T08:30:00.000Z","author":"nazone","content":"<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fnazo%2Fwebtransport-go-chat\" title=\"GitHub - nazo/webtransport-go-chat\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\" loading=\"lazy\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/nazo/webtransport-go-chat\">github.com</a></cite></p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/n/nazone/20230127/20230127163228.png\" width=\"1200\" height=\"409\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>突然興味が出てきて書きましたが特に実用性はありません。webtransport-goがそれなりに使えるのかどうか調べるために書いたものです。</p>\n\n<p><a href=\"https://github.com/quic-go/webtransport-go\">webtransport-goは紆余曲折あって（？）quic-goに取り込まれたようですが</a>、中のファイルがまだ <code>github.com/marten-seemann/webtransport-go</code> のままなので（2023年1月27日現在）、こちらの名前でimportするのが良いです。修正を投げようとも思いましたが関連する他<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>も全て変わっていないので、そのうち修正されるのを待とうと思います。</p>\n\n<p>切断周りの対応はちゃんと書いていません。</p>\n\n<p>チャットメッセージはUnidirectional Streamでやりとりしています。<a href=\"https://www.ietf.org/archive/id/draft-lcurley-warp-00.html\">一部で話題のTwitchのWarp</a>もUnidirectionalで実装されているようです。webtransport-goはDatagramはまだ未対応のようです。</p>\n\n<p>WebTransport自体はコネクションさえ確立されれば後はQUICなので、どうしてもブラウザ上でやりたいことがなければ普通にQUICについて調査することをフォーカスしたほうが良さそうです。ブラウザならではで想定できそうなのはやはり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Warp\">Warp</a>のような動画配信でしょうか。WebCodecsと組み合わせて実装するようです。</p>\n\n<h1 id=\"参考記事\">参考記事</h1>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fqiita.com%2Falivelime%2Fitems%2F539383fd9fdf06169211\" title=\"WebTransportでもテキストチャットがしたい!(WebSocket比較あり) - Qiita\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\" loading=\"lazy\"></iframe><cite class=\"hatena-citation\"><a href=\"https://qiita.com/alivelime/items/539383fd9fdf06169211\">qiita.com</a></cite></p>\n","contentSnippet":"github.com\n\n突然興味が出てきて書きましたが特に実用性はありません。webtransport-goがそれなりに使えるのかどうか調べるために書いたものです。\nwebtransport-goは紆余曲折あって（？）quic-goに取り込まれたようですが、中のファイルがまだ github.com/marten-seemann/webtransport-go のままなので（2023年1月27日現在）、こちらの名前でimportするのが良いです。修正を投げようとも思いましたが関連する他リポジトリも全て変わっていないので、そのうち修正されるのを待とうと思います。\n切断周りの対応はちゃんと書いていません。\nチャットメッセージはUnidirectional Streamでやりとりしています。一部で話題のTwitchのWarpもUnidirectionalで実装されているようです。webtransport-goはDatagramはまだ未対応のようです。\nWebTransport自体はコネクションさえ確立されれば後はQUICなので、どうしてもブラウザ上でやりたいことがなければ普通にQUICについて調査することをフォーカスしたほうが良さそうです。ブラウザならではで想定できそうなのはやはりWarpのような動画配信でしょうか。WebCodecsと組み合わせて実装するようです。\n参考記事\nqiita.com","summary":"github.com 突然興味が出てきて書きましたが特に実用性はありません。webtransport-goがそれなりに使えるのかどうか調べるために書いたものです。 webtransport-goは紆余曲折あって（？）quic-goに取り込まれたようですが、中のファイルがまだ github.com/marten-seemann/webtransport-go のままなので（2023年1月27日現在）、こちらの名前でimportするのが良いです。修正を投げようとも思いましたが関連する他リポジトリも全て変わっていないので、そのうち修正されるのを待とうと思います。 切断周りの対応はちゃんと書いていませ…","id":"hatenablog://entry/4207112889957967595","isoDate":"2023-01-27T08:30:00.000Z"},{"title":"2022年の仕事と近況","link":"https://nazo.hatenablog.com/entry/2022-works","pubDate":"2022-12-29T03:00:00.000Z","author":"nazone","content":"<ul>\n<li>2021年 : <a href=\"https://nazo.hatenablog.com/entry/2021-works\">https://nazo.hatenablog.com/entry/2021-works</a></li>\n<li>2020年 : <a href=\"https://nazo.hatenablog.com/entry/2020-works\">https://nazo.hatenablog.com/entry/2020-works</a></li>\n<li>2019年 : <a href=\"https://nazo.hatenablog.com/entry/goodbye-uuum\">https://nazo.hatenablog.com/entry/goodbye-uuum</a></li>\n</ul>\n\n\n<h1 id=\"2022年の仕事\">2022年の仕事</h1>\n\n<p>去年からの続きの仕事のみで、大きく話せるようなことは特にありません。仕事をしていないわけではないですが、一度区切りをつけて来年からは大幅縮小になる予定です。</p>\n\n<h1 id=\"近況\">近況</h1>\n\n<p>2022年は引っ越したりしていました。一応首都圏ではあるものの、通勤することを完全に捨てた場所にいます。その代わり仕事部屋を手に入れたので、リモートワークで会議が頻繁に発生することにも対応できることになりました。</p>\n\n<p>去年今年と辛いことが続いていますが、来年は本厄らしいのでもうだめかもしれません。がんばります。</p>\n\n<h1 id=\"まとめ\">まとめ</h1>\n\n<p>今後はブログを中心に情報発信を行っていこうと思います。技術的な話は <a href=\"https://zenn.dev/nazo\">Zenn</a> にも転載していますので、技術的な話のみ読みたい方はそちらをフォローしてください。</p>\n\n<p>来年からの予定は今のところ未定なので、週２〜３くらいでの案件を引き続き募集しております。詳しくは\n<a href=\"https://nazo.dev/\">https://nazo.dev/</a> をご覧下さい。</p>\n","contentSnippet":"2021年 : https://nazo.hatenablog.com/entry/2021-works\n2020年 : https://nazo.hatenablog.com/entry/2020-works\n2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum\n2022年の仕事\n去年からの続きの仕事のみで、大きく話せるようなことは特にありません。仕事をしていないわけではないですが、一度区切りをつけて来年からは大幅縮小になる予定です。\n近況\n2022年は引っ越したりしていました。一応首都圏ではあるものの、通勤することを完全に捨てた場所にいます。その代わり仕事部屋を手に入れたので、リモートワークで会議が頻繁に発生することにも対応できることになりました。\n去年今年と辛いことが続いていますが、来年は本厄らしいのでもうだめかもしれません。がんばります。\nまとめ\n今後はブログを中心に情報発信を行っていこうと思います。技術的な話は Zenn にも転載していますので、技術的な話のみ読みたい方はそちらをフォローしてください。\n来年からの予定は今のところ未定なので、週２〜３くらいでの案件を引き続き募集しております。詳しくは\nhttps://nazo.dev/ をご覧下さい。","summary":"2021年 : https://nazo.hatenablog.com/entry/2021-works 2020年 : https://nazo.hatenablog.com/entry/2020-works 2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum 2022年の仕事 去年からの続きの仕事のみで、大きく話せるようなことは特にありません。仕事をしていないわけではないですが、一度区切りをつけて来年からは大幅縮小になる予定です。 近況 2022年は引っ越したりしていました。一応首都圏ではあるものの、通勤することを完全に捨てた場所に…","id":"hatenablog://entry/4207112889941404490","isoDate":"2022-12-29T03:00:00.000Z"},{"title":"最近の Terraform のディレクトリ構造の分け方","link":"https://nazo.hatenablog.com/entry/terraform-2022","pubDate":"2022-12-23T03:00:00.000Z","author":"nazone","content":"<h1 id=\"概要\">概要</h1>\n\n<p>modules / envs / apps で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを切っています。</p>\n\n<h1 id=\"基礎知識-modules-と-envs\">基礎知識： modules と envs</h1>\n\n<p>誰が言い出したのかはわかりませんが、modules と envs に分けるパターンはよく見かけます。</p>\n\n<p>modules は文字通りモジュールを配置するところで、 envs はそれらを使う環境が入っているという感じです。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── modules\n│   ├── vpc\n│   ├── app\n│   └── db\n└── envs\n    ├── production\n    └── staging</pre>\n\n\n<p>modules の抽象度は、 <a href=\"https://12factor.net/ja/backing-services\">12 factor app の バックエンドサービス</a> くらいのイメージを持っていればいいのではないかと思います。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VPC\">VPC</a> みたいな基盤は特殊として、それ以外は「外しても使える程度」を意識するのが良いと思います。</p>\n\n<p>一般的に envs で書かれる tf は、modules を呼び出すだけにしておくのが良いと思います。直接リソースを書くのは最終手段です。</p>\n\n<h1 id=\"modules-と-envs-はわかるけど-apps-って何\">modules と envs はわかるけど apps って何？</h1>\n\n<p>全環境で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VPC\">VPC</a> も DB も分けるなら必要ないですが、「複数のアプリで同一の DB を参照したい」というケースは多々あります。進捗が別々の環境を同時に作りたい場合などです。また、費用を節約するために同一の DB リソースを共有するという場合もあります。</p>\n\n<p>そのような状況を考えた時、「土台のバックエンドサービスと、自分で書いたアプリケーションは別の扱いにしたほうがいいのでは」となりました。この「土台のバックエンドサービス」が「envs」で、「自分で書いたアプリケーション」が「apps」になります。</p>\n\n<p>「envs」は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VPC\">VPC</a> や DB などがまとまったもので、「apps」はデプロイ単位で分けることになります。これにより、１つの <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VPC\">VPC</a> や DB に、複数のアプリケーションを同居させることが簡単になります。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── modules\n│   ├── vpc\n│   ├── app\n│   └── db\n├── apps\n│   ├── staging\n│   ├── production\n│   └── featurexxxx\n└── envs\n    ├── production\n    └── staging</pre>\n\n\n<p>「envs」以下より「apps」以下のほうが必ず数が多くなります。また、「apps」は「envs」の設定に依存しますが、逆の依存は必ず存在しないようにします。</p>\n","contentSnippet":"概要\nmodules / envs / apps でディレクトリを切っています。\n基礎知識： modules と envs\n誰が言い出したのかはわかりませんが、modules と envs に分けるパターンはよく見かけます。\nmodules は文字通りモジュールを配置するところで、 envs はそれらを使う環境が入っているという感じです。\n.\n├── modules\n│   ├── vpc\n│   ├── app\n│   └── db\n└── envs\n    ├── production\n    └── staging\nmodules の抽象度は、 12 factor app の バックエンドサービス くらいのイメージを持っていればいいのではないかと思います。VPC みたいな基盤は特殊として、それ以外は「外しても使える程度」を意識するのが良いと思います。\n一般的に envs で書かれる tf は、modules を呼び出すだけにしておくのが良いと思います。直接リソースを書くのは最終手段です。\nmodules と envs はわかるけど apps って何？\n全環境で VPC も DB も分けるなら必要ないですが、「複数のアプリで同一の DB を参照したい」というケースは多々あります。進捗が別々の環境を同時に作りたい場合などです。また、費用を節約するために同一の DB リソースを共有するという場合もあります。\nそのような状況を考えた時、「土台のバックエンドサービスと、自分で書いたアプリケーションは別の扱いにしたほうがいいのでは」となりました。この「土台のバックエンドサービス」が「envs」で、「自分で書いたアプリケーション」が「apps」になります。\n「envs」は、VPC や DB などがまとまったもので、「apps」はデプロイ単位で分けることになります。これにより、１つの VPC や DB に、複数のアプリケーションを同居させることが簡単になります。\n.\n├── modules\n│   ├── vpc\n│   ├── app\n│   └── db\n├── apps\n│   ├── staging\n│   ├── production\n│   └── featurexxxx\n└── envs\n    ├── production\n    └── staging\n「envs」以下より「apps」以下のほうが必ず数が多くなります。また、「apps」は「envs」の設定に依存しますが、逆の依存は必ず存在しないようにします。","summary":"最近の Terraform のディレクトリ構造の分け方について解説します。","id":"hatenablog://entry/4207112889947280382","isoDate":"2022-12-23T03:00:00.000Z"},{"title":"git の pre-commit hook はなるべく使わないほうがいいのでは","link":"https://nazo.hatenablog.com/entry/dont-use-pre-commit-hook","pubDate":"2022-12-12T03:00:00.000Z","author":"nazone","content":"<p>git に pre-commit hook という、コミット直前に何かのプログラムを実行する機能があります。これを用いて lint や test を実行したりすることがありますが、この利用は極力避けたほうが良いのではと考えています。</p>\n\n<h1 id=\"なぜ\">なぜ？</h1>\n\n<ul>\n<li>個人の環境で実行した結果は信用できない</li>\n<li>ローカルコンピューターで待たせてはいけない</li>\n<li>pre-commit の挙動や中断などで動作が怪しくなることがある</li>\n</ul>\n\n\n<h1 id=\"個人の環境で実行した結果は信用できない\">個人の環境で実行した結果は信用できない</h1>\n\n<p>全員が完全に同じ環境で pre-commit hook を実行しているかは誰にもわかりません。言語やライブラリのバージョンに差がある可能性もあります。また、hook をスキップする方法もあります。</p>\n\n<p>それだけを信用してチェックを行ったと判断するのは危険であるため、CI で実行することを優先すべきです。</p>\n\n<h1 id=\"ローカルコンピューターで待たせてはいけない\">ローカルコンピューターで待たせてはいけない</h1>\n\n<p>チェック項目が増えると、hook の実行時間も増えます。</p>\n\n<p>あくまで hook で行う処理の大半はガードレールなので、ちゃんと書いていれば一発通過するはずで、そのために毎回各自が待たされるのは無駄です。</p>\n\n<p>チェック内容に自信がなければコミット前に手動実行すると思いますので、それでチェックが通っても pre-commit hook は実行され、さらに時間をかけてしまいます。</p>\n\n<p>チェックに時間がかかりすぎるようになると、チェックを迂回するための策を考えてしまう可能性があります。</p>\n\n<p>チェックが通る前提でコードを書き、素早く push して開発を効率化しましょう。</p>\n\n<h1 id=\"pre-commit-の挙動や中断などで動作が怪しくなることがある\">pre-commit の挙動や中断などで動作が怪しくなることがある</h1>\n\n<p>ライブラリの更新などで pre-commit hook がアップデートされた場合などや、極端にリビジョンに差があって pre-commit の挙動に差があるブランチに切り替えた場合などに、pre-commit <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>とライブラリが一致していない等でおかしな挙動をすることがあります。他にも様々な理由で予期せぬ結果を起こすことがあります。</p>\n\n<p>git commit に機能を追加してしまうことで、 git commit 時に git commit 以外のことを考える必要が出てきます。</p>\n\n<h1 id=\"そんなこと言っても変なコードが-push-されたらどうするの\">そんなこと言っても変なコードが push されたらどうするの？</h1>\n\n<p>CI で防げばいいです。そのための CI です。</p>\n\n<p>CI と同等の動作を「任意で」ローカルで実行できることは必要ですが、最終判断はあくまで CI にやらせましょう。</p>\n\n<p>CI で必ずチェックすることで、変なコードがマージされるのを確実に防ぐことができます。また、常に同じ環境である CI に実行させることによって、環境ごとで結果に違いが出るといった現象も防ぐことができます。</p>\n\n<h1 id=\"その割には有名なライブラリたくさんあるし使っている人もいっぱいいるよ\">その割には有名なライブラリたくさんあるし使っている人もいっぱいいるよ！</h1>\n\n<p><a href=\"https://rubygems.org/gems/pre-commit/versions/0.31.0?locale=ja\">Ruby の pre-commit gem</a> や nodejs の <a href=\"https://github.com/typicode/husky\">Husky</a> + <a href=\"https://github.com/okonet/lint-staged\">lint-staged</a> などがあり、特に nodejs 界隈ではボイラープレートに組み込まれていたりします。</p>\n\n<p>どれも有名かつ人気があるので使うべきかと思いますが、「出来がよく実用しても問題ないから人気である」と「必ず使う必要がある」は全く関係がありません。これまでの理由により、基本的には使う必要はないものです。</p>\n\n<p>どうしても忘れっぽい人やチェックする習慣がない初学者は任意で有効化して利用する、というのはありかもしれませんが、強制するものではないと思います。</p>\n\n<p>リモートに push されること自体が望ましくないものを防ぐ場合は使って良いと思います。例えば <a href=\"https://github.com/awslabs/git-secrets\">git-secrets</a> のようなものです。一般的な lint エラーやテストの失敗といったものはリモートに push されても何の問題もありません。誰もマージできないだけです。</p>\n\n<h1 id=\"まとめ\">まとめ</h1>\n\n<p>よほどの理由がない限り、pre-commit hookは使わないほうがいいと思ったほうが良いでしょう。各自の判断で手動実行 + 必ず CI でチェック、でほとんどの場合は十分です。絶対に使うなというわけではないですが、なぜ pre-commit hook を使う必要があるのか、何のために使うのかをよく考えて利用しましょう。</p>\n\n<h1 id=\"参考\">参考</h1>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.thoughtworks.com%2Finsights%2Fblog%2Fpre-commit-don-t-git-hooked\" title=\"Pre-commit: Don’t git hooked!\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\" loading=\"lazy\"></iframe><cite class=\"hatena-citation\"><a href=\"https://www.thoughtworks.com/insights/blog/pre-commit-don-t-git-hooked\">www.thoughtworks.com</a></cite></p>\n","contentSnippet":"git に pre-commit hook という、コミット直前に何かのプログラムを実行する機能があります。これを用いて lint や test を実行したりすることがありますが、この利用は極力避けたほうが良いのではと考えています。\nなぜ？\n個人の環境で実行した結果は信用できない\nローカルコンピューターで待たせてはいけない\npre-commit の挙動や中断などで動作が怪しくなることがある\n個人の環境で実行した結果は信用できない\n全員が完全に同じ環境で pre-commit hook を実行しているかは誰にもわかりません。言語やライブラリのバージョンに差がある可能性もあります。また、hook をスキップする方法もあります。\nそれだけを信用してチェックを行ったと判断するのは危険であるため、CI で実行することを優先すべきです。\nローカルコンピューターで待たせてはいけない\nチェック項目が増えると、hook の実行時間も増えます。\nあくまで hook で行う処理の大半はガードレールなので、ちゃんと書いていれば一発通過するはずで、そのために毎回各自が待たされるのは無駄です。\nチェック内容に自信がなければコミット前に手動実行すると思いますので、それでチェックが通っても pre-commit hook は実行され、さらに時間をかけてしまいます。\nチェックに時間がかかりすぎるようになると、チェックを迂回するための策を考えてしまう可能性があります。\nチェックが通る前提でコードを書き、素早く push して開発を効率化しましょう。\npre-commit の挙動や中断などで動作が怪しくなることがある\nライブラリの更新などで pre-commit hook がアップデートされた場合などや、極端にリビジョンに差があって pre-commit の挙動に差があるブランチに切り替えた場合などに、pre-commit スクリプトとライブラリが一致していない等でおかしな挙動をすることがあります。他にも様々な理由で予期せぬ結果を起こすことがあります。\ngit commit に機能を追加してしまうことで、 git commit 時に git commit 以外のことを考える必要が出てきます。\nそんなこと言っても変なコードが push されたらどうするの？\nCI で防げばいいです。そのための CI です。\nCI と同等の動作を「任意で」ローカルで実行できることは必要ですが、最終判断はあくまで CI にやらせましょう。\nCI で必ずチェックすることで、変なコードがマージされるのを確実に防ぐことができます。また、常に同じ環境である CI に実行させることによって、環境ごとで結果に違いが出るといった現象も防ぐことができます。\nその割には有名なライブラリたくさんあるし使っている人もいっぱいいるよ！\nRuby の pre-commit gem や nodejs の Husky + lint-staged などがあり、特に nodejs 界隈ではボイラープレートに組み込まれていたりします。\nどれも有名かつ人気があるので使うべきかと思いますが、「出来がよく実用しても問題ないから人気である」と「必ず使う必要がある」は全く関係がありません。これまでの理由により、基本的には使う必要はないものです。\nどうしても忘れっぽい人やチェックする習慣がない初学者は任意で有効化して利用する、というのはありかもしれませんが、強制するものではないと思います。\nリモートに push されること自体が望ましくないものを防ぐ場合は使って良いと思います。例えば git-secrets のようなものです。一般的な lint エラーやテストの失敗といったものはリモートに push されても何の問題もありません。誰もマージできないだけです。\nまとめ\nよほどの理由がない限り、pre-commit hookは使わないほうがいいと思ったほうが良いでしょう。各自の判断で手動実行 + 必ず CI でチェック、でほとんどの場合は十分です。絶対に使うなというわけではないですが、なぜ pre-commit hook を使う必要があるのか、何のために使うのかをよく考えて利用しましょう。\n参考\nwww.thoughtworks.com","summary":"git に pre-commit hook という、コミット直前に何かのプログラムを実行する機能があります。これを用いて lint や test を実行したりすることがありますが、この利用は控えたほうが良いと考えています。ここではその詳しい理由を説明します。","id":"hatenablog://entry/4207112889943282748","isoDate":"2022-12-12T03:00:00.000Z"},{"title":"2021年の仕事まとめ","link":"https://nazo.hatenablog.com/entry/2021-works","pubDate":"2021-12-28T03:00:00.000Z","author":"nazone","content":"<ul>\n<li>2020年 : <a href=\"https://nazo.hatenablog.com/entry/2020-works\">https://nazo.hatenablog.com/entry/2020-works</a></li>\n<li>2019年 : <a href=\"https://nazo.hatenablog.com/entry/goodbye-uuum\">https://nazo.hatenablog.com/entry/goodbye-uuum</a></li>\n</ul>\n\n\n<h1>Go による <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> サーバーと React による管理画面開発</h1>\n\n<p>Go で gRPC サーバーを作りつつ、 React と gqlgen で 管理画面を作るというような内容でした。</p>\n\n<p>都合により短期でしか関われなかったのですが、あまりお目にかかれない環境での開発で非常に楽しい経験をさせて頂きました。</p>\n\n<h1>株式会社ハグカム　様</h1>\n\n<p><a href=\"https://www.global-crown.com/\">GLOBAL CROWN</a> という子ども向け英会話サービスを提供しております。<a href=\"https://prtimes.jp/main/html/rd/p/000000004.000019731.html\">今年初めに資金調達も行っており</a> 、絶賛成長中のサービスになっております。</p>\n\n<p>私も少しだけお世話になっており、主にコア<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>からは少し距離を置いたものを中心に、以下のような内容を行っておりました。</p>\n\n<ul>\n<li>GCE で動いていたインフラを Cloud Run に移行</li>\n<li>インフラの Terraform 化</li>\n<li>linter を整備してコード品質を上げる</li>\n<li>CI / CD の整備</li>\n<li>負荷チューニング</li>\n<li>Docker 開発環境の整備</li>\n<li>言語や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>のアップグレード</li>\n</ul>\n\n\n<p>サーバーサイドの言語としては <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/PHP\">PHP</a> と <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Ruby\">Ruby</a> を利用しており、久々に長期で <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/PHP\">PHP</a> を触っていました。</p>\n\n<p>また、<a href=\"https://www.hugcome.co.jp/\">コーポレートサイト</a> を Next.js + Netlify で SSG 化したり、未公開の内容についての対応なども行っておりました。</p>\n\n<p>今年は仕事以外のところでいろいろあったのですが、ハグカム様にはかなり融通を利かせて頂いて助かりました。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Rails\">Rails</a> エンジニアや Flutter エンジニアなどを積極的に採用中ですので、興味があれば以下から応募するか私までご連絡下さい。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.hugcome.co.jp%2Fengineer\" title=\"ソフトウェアエンジニア | 株式会社ハグカム\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://www.hugcome.co.jp/engineer\">www.hugcome.co.jp</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.green-japan.com%2Fcompany%2F8109\" title=\"株式会社 ハグカム | IT/Web業界への転職ならGreen(グリーン)\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://www.green-japan.com/company/8109\">www.green-japan.com</a></cite></p>\n\n<h1>まとめ</h1>\n\n<p>今年はプライベートで良くないことが続く年でしたが、来年後半からはまた良い状況が生まれてくるはずなので、そこから活動を増やしていきたいと考えています。</p>\n\n<p>引き続きお仕事を募集しております。詳細は <a href=\"https://nazo.dev/profile\">https://nazo.dev/profile</a> をご覧下さい。</p>\n","contentSnippet":"2020年 : https://nazo.hatenablog.com/entry/2020-works\n2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum\nGo による API サーバーと React による管理画面開発\nGo で gRPC サーバーを作りつつ、 React と gqlgen で 管理画面を作るというような内容でした。\n都合により短期でしか関われなかったのですが、あまりお目にかかれない環境での開発で非常に楽しい経験をさせて頂きました。\n株式会社ハグカム　様\nGLOBAL CROWN という子ども向け英会話サービスを提供しております。今年初めに資金調達も行っており 、絶賛成長中のサービスになっております。\n私も少しだけお世話になっており、主にコアドメインからは少し距離を置いたものを中心に、以下のような内容を行っておりました。\nGCE で動いていたインフラを Cloud Run に移行\nインフラの Terraform 化\nlinter を整備してコード品質を上げる\nCI / CD の整備\n負荷チューニング\nDocker 開発環境の整備\n言語やフレームワークのアップグレード\nサーバーサイドの言語としては PHP と Ruby を利用しており、久々に長期で PHP を触っていました。\nまた、コーポレートサイト を Next.js + Netlify で SSG 化したり、未公開の内容についての対応なども行っておりました。\n今年は仕事以外のところでいろいろあったのですが、ハグカム様にはかなり融通を利かせて頂いて助かりました。\nRails エンジニアや Flutter エンジニアなどを積極的に採用中ですので、興味があれば以下から応募するか私までご連絡下さい。\nwww.hugcome.co.jp\nwww.green-japan.com\nまとめ\n今年はプライベートで良くないことが続く年でしたが、来年後半からはまた良い状況が生まれてくるはずなので、そこから活動を増やしていきたいと考えています。\n引き続きお仕事を募集しております。詳細は https://nazo.dev/profile をご覧下さい。","summary":"2020年 : https://nazo.hatenablog.com/entry/2020-works 2019年 : https://nazo.hatenablog.com/entry/goodbye-uuum Go による API サーバーと React による管理画面開発 Go で gRPC サーバーを作りつつ、 React と gqlgen で 管理画面を作るというような内容でした。 都合により短期でしか関われなかったのですが、あまりお目にかかれない環境での開発で非常に楽しい経験をさせて頂きました。 株式会社ハグカム 様 GLOBAL CROWN という子ども向け英会話サービスを提供…","id":"hatenablog://entry/26006613716445536","isoDate":"2021-12-28T03:00:00.000Z"},{"title":"ent ( entgo.io/ent ) で ULID を使う","link":"https://nazo.hatenablog.com/entry/entgo-ulid","pubDate":"2021-03-09T03:00:00.000Z","author":"nazone","content":"<p>ent では UUID 型がデフォルトでサポートされているのですが、それとは別に <a href=\"https://github.com/ulid/spec\">ULID</a> を使う方法を解説します。</p>\n\n<p>ULID の実装は <a href=\"https://github.com/oklog/ulid\">https://github.com/oklog/ulid</a> を使用します。</p>\n\n<p>ent の UUID 型は、<a href=\"https://golang.org/pkg/database/sql/driver/#Valuer\">driver.Valuer</a> Interface を利用して値を取得しますが、 oklog/ulid の <code>Value()</code> の実装がバイナリを返却するようになっているため、このままでは可読性が悪いです。 <code>Value()</code> が String を返すようにした ULID 型を新たに定義するのが良いでしょう。そのようにすると、他の interface も実装する必要があります。</p>\n\n<p>結論から言うと <a href=\"https://github.com/ent/contrib/blob/6623819401500db45747a2419172963217cef619/entgql/internal/todopulid/ent/schema/pulid/pulid.go\">https://github.com/ent/contrib/blob/6623819401500db45747a2419172963217cef619/entgql/internal/todopulid/ent/schema/pulid/pulid.go</a> にそのものの実装があります<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\">1</a></sup>。この実装はライブラリ化されているものではない（ internal ）ので、そのままコピペして利用するのが良いでしょう。</p>\n\n<p>使用する場合には以下のようになります。</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synComment\">// Fields of the User.</span>\n<span class=\"synStatement\">func</span> (User) Fields() []ent.Field {\n    <span class=\"synStatement\">return</span> []ent.Field{\n        field.String(<span class=\"synConstant\">&quot;id&quot;</span>).\n            GoType(pulid.ID(<span class=\"synConstant\">&quot;&quot;</span>)).\n            DefaultFunc(<span class=\"synType\">func</span>() pulid.ID { <span class=\"synStatement\">return</span> pulid.MustNew(<span class=\"synConstant\">&quot;US&quot;</span>) }),\n        field.Int(<span class=\"synConstant\">&quot;age&quot;</span>).Positive(),\n        field.String(<span class=\"synConstant\">&quot;name&quot;</span>).Default(<span class=\"synConstant\">&quot;unknown&quot;</span>),\n    }\n}\n</pre>\n\n\n<p>prefixが不要な場合はprefixの部分を削ってしまうのが良いかと思います。</p>\n\n<p>このままの実装でもう少し手軽に書きたい場合は、同<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>に <a href=\"https://github.com/ent/contrib/blob/6623819401500db45747a2419172963217cef619/entgql/internal/todopulid/ent/schema/pulid/mixin.go\">mixin</a> が存在しますので、これを持ち出すと良いと思います。</p>\n\n<p>ent は各フィールドを固有の型にできますので、例えば上記例で ID を <code>UserID</code> 型にしたい場合は以下のようになります。</p>\n\n<pre class=\"code lang-go\" data-lang=\"go\" data-unlink><span class=\"synStatement\">type</span> UserID pulid.ID\n\n<span class=\"synComment\">// Fields of the User.</span>\n<span class=\"synStatement\">func</span> (User) Fields() []ent.Field {\n    <span class=\"synStatement\">return</span> []ent.Field{\n        field.String(<span class=\"synConstant\">&quot;id&quot;</span>).\n            GoType(UserID(<span class=\"synConstant\">&quot;&quot;</span>)).\n            DefaultFunc(<span class=\"synType\">func</span>() UserID { <span class=\"synStatement\">return</span> UserID(pulid.MustNew(<span class=\"synConstant\">&quot;US&quot;</span>)) }),\n        field.Int(<span class=\"synConstant\">&quot;age&quot;</span>).Positive(),\n        field.String(<span class=\"synConstant\">&quot;name&quot;</span>).Default(<span class=\"synConstant\">&quot;unknown&quot;</span>),\n    }\n}\n</pre>\n\n<div class=\"footnotes\">\n<hr/>\n<ol>\n<li id=\"fn:1\">\n<p><a href=\"https://github.com/tmc/pulid\">https://github.com/tmc/pulid</a> のように見えるのですが、こちらは <code>Value()</code> はバイナリを返すようです。<a href=\"#fnref:1\" rev=\"footnote\">&#8617;</a></p></li>\n</ol>\n</div>\n\n","contentSnippet":"ent では UUID 型がデフォルトでサポートされているのですが、それとは別に ULID を使う方法を解説します。\nULID の実装は https://github.com/oklog/ulid を使用します。\nent の UUID 型は、driver.Valuer Interface を利用して値を取得しますが、 oklog/ulid の Value() の実装がバイナリを返却するようになっているため、このままでは可読性が悪いです。 Value() が String を返すようにした ULID 型を新たに定義するのが良いでしょう。そのようにすると、他の interface も実装する必要があります。\n結論から言うと https://github.com/ent/contrib/blob/6623819401500db45747a2419172963217cef619/entgql/internal/todopulid/ent/schema/pulid/pulid.go にそのものの実装があります1。この実装はライブラリ化されているものではない（ internal ）ので、そのままコピペして利用するのが良いでしょう。\n使用する場合には以下のようになります。\n// Fields of the User.\nfunc (User) Fields() []ent.Field {\n    return []ent.Field{\n        field.String(\"id\").\n            GoType(pulid.ID(\"\")).\n            DefaultFunc(func() pulid.ID { return pulid.MustNew(\"US\") }),\n        field.Int(\"age\").Positive(),\n        field.String(\"name\").Default(\"unknown\"),\n    }\n}\n\n\n\nprefixが不要な場合はprefixの部分を削ってしまうのが良いかと思います。\nこのままの実装でもう少し手軽に書きたい場合は、同リポジトリに mixin が存在しますので、これを持ち出すと良いと思います。\nent は各フィールドを固有の型にできますので、例えば上記例で ID を UserID 型にしたい場合は以下のようになります。\ntype UserID pulid.ID\n\n// Fields of the User.\nfunc (User) Fields() []ent.Field {\n    return []ent.Field{\n        field.String(\"id\").\n            GoType(UserID(\"\")).\n            DefaultFunc(func() UserID { return UserID(pulid.MustNew(\"US\")) }),\n        field.Int(\"age\").Positive(),\n        field.String(\"name\").Default(\"unknown\"),\n    }\n}\n\n\n\n\n\n\nhttps://github.com/tmc/pulid のように見えるのですが、こちらは Value() はバイナリを返すようです。↩","summary":"ent では UUID 型がデフォルトでサポートされているのですが、それとは別に ULID を使う方法を解説します。 ULID の実装は https://github.com/oklog/ulid を使用します。 ent の UUID 型は、driver.Valuer Interface を利用して値を取得しますが、 oklog/ulid の Value() の実装がバイナリを返却するようになっているため、このままでは可読性が悪いです。 Value() が String を返すようにした ULID 型を新たに定義するのが良いでしょう。そのようにすると、他の interface も実装する必要が…","id":"hatenablog://entry/26006613701103637","isoDate":"2021-03-09T03:00:00.000Z"},{"title":" Infrastructure as Codeは最初からやったほうがいい","link":"https://nazo.hatenablog.com/entry/iac-first","pubDate":"2021-03-08T03:00:00.000Z","author":"nazone","content":"<p>最近不慣れな <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> を触ることがあったのですが、最初から Terraform で書くようにしたほうが楽だったので、それについて解説しようと思います。</p>\n\n<h1>Web のコンソールを触るのが怖い</h1>\n\n<p>他のサービスが同居しているアカウントでインフラを操作すると、他のサービスに影響を与えてしまうのでは…という不安があります。関係のないサービスは別アカウントにするというのがベストプ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>ティスですが、様々な事情によりそれができない場合もあります。</p>\n\n<p>最初から IaC で触っていれば、コードで生成したインフラ以外を触ることがなく、削除する時も間違えることがなく削除することができ、何度も作り直して試すことが容易になります。</p>\n\n<h1>手順を覚えられない</h1>\n\n<p>Webのコンソールでも、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%DE%A5%F3%A5%C9%A5%E9%A5%A4%A5%F3\">コマンドライン</a>ツールでも同様ですが、作業した内容を記録しておく必要があります。記録していない場合、同じ環境を再現することができません。</p>\n\n<p>最初からコード化をしていれば、手順を覚えておく必要もありません。</p>\n\n<h1>必要な依存関係を最初から教えてくれる</h1>\n\n<p>コンソールで触っていると、どのサービスとどのサービスが繋がっているかというのがわかりにくいですが、例えば Terraform では必須パラメーターとして存在していることが多く、依存関係を設定していないと適用する前にエラーになってくれたりするので迷うことが少なくなります。</p>\n\n<p>また、サンプルで組み合わせた書き方が充実していたり、組み合わせサンプルのコードが用意されていたりするので、手順を読んで試行錯誤するより確実にインフラ構築をすることができます。</p>\n\n<p>特に <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AWS\">AWS</a> で CDK や Copilot といったツールを使っておくと、複雑なサービス間の依存関係を考えることがなく構成を立ち上げることができます。</p>\n\n<h1>設定できるパラメーターがツールのドキュメントに網羅されている</h1>\n\n<p>依存関係と同様に、全てのパラメーターがドキュメントに書かれているので、「このリソースではこれが設定できる」とか「このリソースはこの設定をすることができない」というのがドキュメントを読むだけで把握することができます。</p>\n\n<p>ただし <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GCP\">GCP</a> の Cloud Run のような<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%C7%A1%BC%A5%BF\">メタデータ</a>でパラメーターを指定するような類のものの場合や、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AWS\">AWS</a> RDS のパラメーターグループのような任意のものを指定するようなものはドキュメントには書かれていないので、そこはオフィシャルのドキュメントやコンソールの画面を併せて読む必要があります。</p>\n\n<h1>まとめ</h1>\n\n<p>コンソールで試行錯誤するより、最初からコードで書いて試行錯誤したほうが良いことが多いです。手作業を後からコード化するのは二度手間にもなるので、学習目的とかでない限りは最初からコードを書きましょう。</p>\n\n<p>もちろんある程度の IaC ツールに慣れておく必要や、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\">クラウド</a>インフラの使い方に慣れておく必要がありますので、そこは基礎教養として素振りしておきましょう。</p>\n","contentSnippet":"最近不慣れな GCP を触ることがあったのですが、最初から Terraform で書くようにしたほうが楽だったので、それについて解説しようと思います。\nWeb のコンソールを触るのが怖い\n他のサービスが同居しているアカウントでインフラを操作すると、他のサービスに影響を与えてしまうのでは…という不安があります。関係のないサービスは別アカウントにするというのがベストプラクティスですが、様々な事情によりそれができない場合もあります。\n最初から IaC で触っていれば、コードで生成したインフラ以外を触ることがなく、削除する時も間違えることがなく削除することができ、何度も作り直して試すことが容易になります。\n手順を覚えられない\nWebのコンソールでも、コマンドラインツールでも同様ですが、作業した内容を記録しておく必要があります。記録していない場合、同じ環境を再現することができません。\n最初からコード化をしていれば、手順を覚えておく必要もありません。\n必要な依存関係を最初から教えてくれる\nコンソールで触っていると、どのサービスとどのサービスが繋がっているかというのがわかりにくいですが、例えば Terraform では必須パラメーターとして存在していることが多く、依存関係を設定していないと適用する前にエラーになってくれたりするので迷うことが少なくなります。\nまた、サンプルで組み合わせた書き方が充実していたり、組み合わせサンプルのコードが用意されていたりするので、手順を読んで試行錯誤するより確実にインフラ構築をすることができます。\n特に AWS で CDK や Copilot といったツールを使っておくと、複雑なサービス間の依存関係を考えることがなく構成を立ち上げることができます。\n設定できるパラメーターがツールのドキュメントに網羅されている\n依存関係と同様に、全てのパラメーターがドキュメントに書かれているので、「このリソースではこれが設定できる」とか「このリソースはこの設定をすることができない」というのがドキュメントを読むだけで把握することができます。\nただし GCP の Cloud Run のようなメタデータでパラメーターを指定するような類のものの場合や、AWS RDS のパラメーターグループのような任意のものを指定するようなものはドキュメントには書かれていないので、そこはオフィシャルのドキュメントやコンソールの画面を併せて読む必要があります。\nまとめ\nコンソールで試行錯誤するより、最初からコードで書いて試行錯誤したほうが良いことが多いです。手作業を後からコード化するのは二度手間にもなるので、学習目的とかでない限りは最初からコードを書きましょう。\nもちろんある程度の IaC ツールに慣れておく必要や、クラウドインフラの使い方に慣れておく必要がありますので、そこは基礎教養として素振りしておきましょう。","summary":"最近不慣れな GCP を触ることがあったのですが、最初から Terraform で書くようにしたほうが楽だったので、それについて解説しようと思います。 Web のコンソールを触るのが怖い 他のサービスが同居しているアカウントでインフラを操作すると、他のサービスに影響を与えてしまうのでは…という不安があります。関係のないサービスは別アカウントにするというのがベストプラクティスですが、様々な事情によりそれができない場合もあります。 最初から IaC で触っていれば、コードで生成したインフラ以外を触ることがなく、削除する時も間違えることがなく削除することができ、何度も作り直して試すことが容易になりま…","id":"hatenablog://entry/26006613698278372","isoDate":"2021-03-08T03:00:00.000Z"},{"title":"Webエンジニアが新規でプロジェクトに入った時に確認すること","link":"https://nazo.hatenablog.com/entry/project-onboarding","pubDate":"2021-03-03T03:00:00.000Z","author":"nazone","content":"<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EA%A1%BC%A5%E9%A5%F3%A5%B9\">フリーランス</a>としてWebエンジニアをしておりますが、プロジェクトに新規に入った時にどういう点を確認しているのかをまとめておきたいと思います。</p>\n\n<h1>プロジェクトの目標と直近の目標が問題ないか</h1>\n\n<p>プロジェクトの最終目標（理想）はとにかく大きくあるべきで、一方で直近の目標は具体的かつ十分に実現可能なサイズになっているべきです。もちろんその間くらいの目標（いわゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%A4%A5%EB%A5%B9%A5%C8%A1%BC%A5%F3\">マイルストーン</a>）も存在しているはずです。</p>\n\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EA%A1%BC%A5%E9%A5%F3%A5%B9\">フリーランス</a>の立場だと目標そのものに直接口を出すことはないですが、直近の目標が大きすぎると手を動かす時に困ってしまいますので、どこを削ぎ落とすのが良いのかこちらから提案することはあります。</p>\n\n<h1><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B3%AB%C8%AF%A5%D7%A5%ED%A5%BB%A5%B9\">開発プロセス</a>が問題ないか</h1>\n\n<p>プロジェクト参加直後はベロシティ（スプリント期間内の平均作業量）が不安定ですので、そこを許容できてちゃんと</p>\n\n<p>個人的には常に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%E9%A5%E0\">スクラム</a>である必要はないと思いますが、マネージャーがいる場合はマネージャーが各メンバーのベロシティをちゃんと把握している、不在の場合は自分でベロシティが把握できていてタスクの見積もりができる、という状況になっていれば良いかと思います。「何だかよくわからないタスクをよくわからない期間で対応している」という状況では、前述の直近の目標の提案と同時に対処方法の提案を行うこともあります。</p>\n\n<h1>デプロイが安定かつ高速に行えているか</h1>\n\n<p>デプロイ速度は修正速度に直接繋がりますし、安定したデプロイができなければデプロイする単位が大きくなりがちですので、デプロイの安定性は最重要になります。</p>\n\n<p>当然デプロイは完全自動化されていて、誰でも気軽に（承認フローなどは別として）デプロイできることが前提です。</p>\n\n<p>誰でも簡単にデプロイできない場合、誰かにデプロイをお願いするというようなことが発生します。これでは自分と誰かの作業と、それを連絡する作業が増えてしまい、当然作業効率が悪くなってしまいますので、「誰でも」は重要です。「コマンド一発でデプロイできる」と見えても「（コマンドを実行する前にアクセスキーを取得して手元でデプロイ準備をして…）コマンド一発でデプロイできる」という場合がよくありますので、デプロイ環境自体が CI/CD 環境に移されていて手元の環境に影響せずデプロイできる（ CI サーバーが落ちていた場合は手元でも実行できる）というのが理想です。</p>\n\n<h1>デプロイ方法が複雑になっていないか</h1>\n\n<p>安定して高速にデプロイできていても、それを処理している方法が複雑だとメンテナンスの時に困ります。</p>\n\n<p>メインのコードは綺麗にできてもインフラ系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>は長くなりがちみたいなケースはよく見かけますが、インフラ系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>もメインのコード同様に読みやすく構造化されているべきです。またインフラ系はツールが充実していることが多いので、なるべく自分で書く<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>は最小限にするのが良いと思います。</p>\n\n<p>デプロイ自体が安定高速動作していればとりあえずは問題ないので、ここは後回しにすることも多いです。</p>\n\n<h1>CI でコード品質が十分に守られているか</h1>\n\n<p>CI の整備は後になればなるほど大変です。<sup id=\"fnref:1\"><a href=\"#fn:1\" rel=\"footnote\">1</a></sup>これは CI で行うことの多くはコード品質そのものを一定の品質にする（ lint など）もののため、コード量が増えた後からそれを適用しようとすると修正点が膨大になるためです。\nlint はとにかくコード量が増える前に対処することが大事なので、ここは真っ先にチェックを行います。リリース前プロジェクトであればすぐ導入しますが、リリース後だと手を入れにくいので、最小限の設定にして少しずつ厳しくするという手法を採ります。</p>\n\n<p>（自動）テストはそもそもテストが書けているかというのをまず確認しますが、その上で「テストに再現性があるか」「テストの内容が十分か」「<a href=\"https://testing.googleblog.com/2010/12/test-sizes.html\">Test Sizes</a> の分類が十分にできているか」といった内容を確認します。</p>\n\n<p>数回に１回落ちるようなテストがある場合で、それがテストの実行順に影響している場合はテストの書き方そのものに問題がある場合がほとんどですので、その場合は削除してしまったほうが良いことが多いです。一方で、時間に関わるテストや、乱数や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BF%F4%C3%CD%B7%D7%BB%BB\">数値計算</a>の誤差などが影響するようなテストは、それ自体が重要なケースが多いのでちゃんと調査したほうがいいと思います。</p>\n\n<p><a href=\"https://testing.googleblog.com/2010/12/test-sizes.html\">Test Sizes</a> は、テストの分類を「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C3%B1%C2%CE%A5%C6%A5%B9%A5%C8\">単体テスト</a>」「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B7%EB%B9%E7%A5%C6%A5%B9%A5%C8\">結合テスト</a>」といった曖昧な呼び方ではなく、「我々のプロジェクトでは３段階の分類があり、それぞれのレベルではこうなっている」というものをプロジェクト固有で定義しようというものです。</p>\n\n<h1>ローカルでの環境構築が問題なく行えるか</h1>\n\n<p>自分が受け入れられる側になるのですが、この時に受け入れ準備が十分にできているか確認し、できていない場合は改善しながら作業することになります。</p>\n\n<p>一番ありがちなのは環境構築手順が整備されていないということで、これは自分がそのまま作業するのですぐわかります。</p>\n\n<p>ローカルの開発に外部のサーバーが必要な場合はまずそれがローカルで再現できないのか確認します。単なる <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MySQL\">MySQL</a> や <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/PostgreSQL\">PostgreSQL</a> などをサーバーに繋いでいる場合はローカルで立ち上げるように変更します。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%DF%A5%E5%A5%EC%A1%BC%A5%BF%A1%BC\">エミュレーター</a>が用意されているサービスであればそちらを使うようにします。この際に設定が直接書かれていたり ENV などでの切り替えしか対応していない場合は、設定を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a>に出して変更可能にします。<sup id=\"fnref:2\"><a href=\"#fn:2\" rel=\"footnote\">2</a></sup>\n最近だと自分は M1 (<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Apple\">Apple</a> Silicon) <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac\">Mac</a> を使用しているので、この環境で動作しないものを使っているという場面に遭遇することもあります。この場合は Docker 化を真っ先に行います。</p>\n\n<p>手順はあるけど手順通りにやっても上手く行かないという場合、「使っているライブラリのアップデートで動かなくなった」というケースと「プログラムの構造の変化に対応していない」というケースが多いです。どちらにしても変更を把握できていないということが原因ですので、メンテナンス体制に難があることが多いです。外部ライブラリの更新などは把握しておく、自分で修正した場合は環境構築手順もアップデートするフローにしておく、ということが必要になります。</p>\n\n<h1>受け入れタスクが十分に実施可能な内容になっているか</h1>\n\n<p>ここでの障害は「ライブラリやツールの使い方が独自性の強いものになっていないか」「暗黙の知識が多用されていないか」といったものがあります。もちろん前述までの内容がクリアになっていないと作業に入ることもできませんので、それらを取り除いた後にようやく作業ができるということになります。</p>\n\n<p>「ライブラリやツールの使い方が独自性の強いものになっていないか」というのは、自作ライブラリとかを使っている場合は当然ですが、ベストプ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>ティスに即していないようなライブラリの使い方をしているとか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CB%E2%B2%FE%C2%A4\">魔改造</a>されているというような場合には、なるべく本来の使い方に戻すよう指摘することがあります。「ライブラリやツールの公式の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C1%A5%E5%A1%BC%A5%C8%A5%EA%A5%A2%A5%EB\">チュートリアル</a>を見た上でそれを使っている部分を読んだ時にすぐ理解できるようになっているか」というのが指標になります。</p>\n\n<p>「暗黙の知識が多用されていないか」はそのままですが、プロジェクト固有の暗黙の知識がある場合は当然手を入れることができません。暗黙の知識が登場する場合はコメントなどで把握できるようになっていること、仕様と実態の乖離がないことなどを確認します。</p>\n\n<h1>まとめ</h1>\n\n<p>これらの点がクリアされているプロジェクトであれば、新しく人を入れることも容易ですし、引き継ぎの時にも困らないのではないかと思います。</p>\n\n<p>書き漏れがあるかもしれないので、思い出したら追記する可能性があります。</p>\n\n<p>今回はインフラの話は除外しましたが、インフラでチェックする点もまた機会があればまとめてみたいと思います。</p>\n\n<p>これらの点でお悩みの方は是非私までご相談をお願いします。詳細は <a href=\"https://nazo.dev/profile\">https://nazo.dev/profile</a> をご覧下さい。</p>\n<div class=\"footnotes\">\n<hr/>\n<ol>\n<li id=\"fn:1\">\n<p><a href=\"https://www.slideshare.net/nazone/ss-205324165\">https://www.slideshare.net/nazone/ss-205324165</a> もご覧下さい。<a href=\"#fnref:1\" rev=\"footnote\">&#8617;</a></p></li>\n<li id=\"fn:2\">\n<p><a href=\"https://12factor.net/ja/config\">https://12factor.net/ja/config</a><a href=\"#fnref:2\" rev=\"footnote\">&#8617;</a></p></li>\n</ol>\n</div>\n\n","contentSnippet":"フリーランスとしてWebエンジニアをしておりますが、プロジェクトに新規に入った時にどういう点を確認しているのかをまとめておきたいと思います。\nプロジェクトの目標と直近の目標が問題ないか\nプロジェクトの最終目標（理想）はとにかく大きくあるべきで、一方で直近の目標は具体的かつ十分に実現可能なサイズになっているべきです。もちろんその間くらいの目標（いわゆるマイルストーン）も存在しているはずです。\nフリーランスの立場だと目標そのものに直接口を出すことはないですが、直近の目標が大きすぎると手を動かす時に困ってしまいますので、どこを削ぎ落とすのが良いのかこちらから提案することはあります。\n開発プロセスが問題ないか\nプロジェクト参加直後はベロシティ（スプリント期間内の平均作業量）が不安定ですので、そこを許容できてちゃんと\n個人的には常にスクラムである必要はないと思いますが、マネージャーがいる場合はマネージャーが各メンバーのベロシティをちゃんと把握している、不在の場合は自分でベロシティが把握できていてタスクの見積もりができる、という状況になっていれば良いかと思います。「何だかよくわからないタスクをよくわからない期間で対応している」という状況では、前述の直近の目標の提案と同時に対処方法の提案を行うこともあります。\nデプロイが安定かつ高速に行えているか\nデプロイ速度は修正速度に直接繋がりますし、安定したデプロイができなければデプロイする単位が大きくなりがちですので、デプロイの安定性は最重要になります。\n当然デプロイは完全自動化されていて、誰でも気軽に（承認フローなどは別として）デプロイできることが前提です。\n誰でも簡単にデプロイできない場合、誰かにデプロイをお願いするというようなことが発生します。これでは自分と誰かの作業と、それを連絡する作業が増えてしまい、当然作業効率が悪くなってしまいますので、「誰でも」は重要です。「コマンド一発でデプロイできる」と見えても「（コマンドを実行する前にアクセスキーを取得して手元でデプロイ準備をして…）コマンド一発でデプロイできる」という場合がよくありますので、デプロイ環境自体が CI/CD 環境に移されていて手元の環境に影響せずデプロイできる（ CI サーバーが落ちていた場合は手元でも実行できる）というのが理想です。\nデプロイ方法が複雑になっていないか\n安定して高速にデプロイできていても、それを処理している方法が複雑だとメンテナンスの時に困ります。\nメインのコードは綺麗にできてもインフラ系のスクリプトは長くなりがちみたいなケースはよく見かけますが、インフラ系のスクリプトもメインのコード同様に読みやすく構造化されているべきです。またインフラ系はツールが充実していることが多いので、なるべく自分で書くスクリプトは最小限にするのが良いと思います。\nデプロイ自体が安定高速動作していればとりあえずは問題ないので、ここは後回しにすることも多いです。\nCI でコード品質が十分に守られているか\nCI の整備は後になればなるほど大変です。1これは CI で行うことの多くはコード品質そのものを一定の品質にする（ lint など）もののため、コード量が増えた後からそれを適用しようとすると修正点が膨大になるためです。\nlint はとにかくコード量が増える前に対処することが大事なので、ここは真っ先にチェックを行います。リリース前プロジェクトであればすぐ導入しますが、リリース後だと手を入れにくいので、最小限の設定にして少しずつ厳しくするという手法を採ります。\n（自動）テストはそもそもテストが書けているかというのをまず確認しますが、その上で「テストに再現性があるか」「テストの内容が十分か」「Test Sizes の分類が十分にできているか」といった内容を確認します。\n数回に１回落ちるようなテストがある場合で、それがテストの実行順に影響している場合はテストの書き方そのものに問題がある場合がほとんどですので、その場合は削除してしまったほうが良いことが多いです。一方で、時間に関わるテストや、乱数や数値計算の誤差などが影響するようなテストは、それ自体が重要なケースが多いのでちゃんと調査したほうがいいと思います。\nTest Sizes は、テストの分類を「単体テスト」「結合テスト」といった曖昧な呼び方ではなく、「我々のプロジェクトでは３段階の分類があり、それぞれのレベルではこうなっている」というものをプロジェクト固有で定義しようというものです。\nローカルでの環境構築が問題なく行えるか\n自分が受け入れられる側になるのですが、この時に受け入れ準備が十分にできているか確認し、できていない場合は改善しながら作業することになります。\n一番ありがちなのは環境構築手順が整備されていないということで、これは自分がそのまま作業するのですぐわかります。\nローカルの開発に外部のサーバーが必要な場合はまずそれがローカルで再現できないのか確認します。単なる MySQL や PostgreSQL などをサーバーに繋いでいる場合はローカルで立ち上げるように変更します。エミュレーターが用意されているサービスであればそちらを使うようにします。この際に設定が直接書かれていたり ENV などでの切り替えしか対応していない場合は、設定を環境変数に出して変更可能にします。2\n最近だと自分は M1 (Apple Silicon) Mac を使用しているので、この環境で動作しないものを使っているという場面に遭遇することもあります。この場合は Docker 化を真っ先に行います。\n手順はあるけど手順通りにやっても上手く行かないという場合、「使っているライブラリのアップデートで動かなくなった」というケースと「プログラムの構造の変化に対応していない」というケースが多いです。どちらにしても変更を把握できていないということが原因ですので、メンテナンス体制に難があることが多いです。外部ライブラリの更新などは把握しておく、自分で修正した場合は環境構築手順もアップデートするフローにしておく、ということが必要になります。\n受け入れタスクが十分に実施可能な内容になっているか\nここでの障害は「ライブラリやツールの使い方が独自性の強いものになっていないか」「暗黙の知識が多用されていないか」といったものがあります。もちろん前述までの内容がクリアになっていないと作業に入ることもできませんので、それらを取り除いた後にようやく作業ができるということになります。\n「ライブラリやツールの使い方が独自性の強いものになっていないか」というのは、自作ライブラリとかを使っている場合は当然ですが、ベストプラクティスに即していないようなライブラリの使い方をしているとか、魔改造されているというような場合には、なるべく本来の使い方に戻すよう指摘することがあります。「ライブラリやツールの公式のチュートリアルを見た上でそれを使っている部分を読んだ時にすぐ理解できるようになっているか」というのが指標になります。\n「暗黙の知識が多用されていないか」はそのままですが、プロジェクト固有の暗黙の知識がある場合は当然手を入れることができません。暗黙の知識が登場する場合はコメントなどで把握できるようになっていること、仕様と実態の乖離がないことなどを確認します。\nまとめ\nこれらの点がクリアされているプロジェクトであれば、新しく人を入れることも容易ですし、引き継ぎの時にも困らないのではないかと思います。\n書き漏れがあるかもしれないので、思い出したら追記する可能性があります。\n今回はインフラの話は除外しましたが、インフラでチェックする点もまた機会があればまとめてみたいと思います。\nこれらの点でお悩みの方は是非私までご相談をお願いします。詳細は https://nazo.dev/profile をご覧下さい。\nhttps://www.slideshare.net/nazone/ss-205324165 もご覧下さい。↩\n\n\nhttps://12factor.net/ja/config↩","summary":"フリーランスとしてWebエンジニアをしておりますが、プロジェクトに新規に入った時にどういう点を確認しているのかをまとめておきたいと思います。","id":"hatenablog://entry/26006613698182809","isoDate":"2021-03-03T03:00:00.000Z"}]},"__N_SSG":true}